use std::collections::HashMap;

use cp_rs::io::*;
#[allow(unused_mut)]
fn main() {
    let mut io = Io::from_file("day16.txt");
    // let mut io = Io::from_file("test.txt");
    // let mut nodes: HashMap<String, (usize, bool)> = HashMap::new();
    // let mut edges: HashMap<String, Vec<String>> = HashMap::new();
    let mut node_map = HashMap::new();
    let mut nodes: Vec<(usize, (usize, bool))> = vec![];
    let mut edges: Vec<(usize, Vec<usize>)> = vec![];
    let mut edges_temp: Vec<(usize, Vec<String>)> = vec![];
    let mut node_num = 0;
    for mut line in io.line_io() {
        let (source, rate): (String, usize) = line.tuple();
        let destinations: Vec<String> =
            line.read_all().split(", ").map(|x| x.to_string()).collect();
        node_map.insert(source, node_num);
        nodes.push((node_num, (rate, false)));
        edges_temp.push((node_num, destinations));
        node_num += 1;
    }
    for (source, vec) in edges_temp.into_iter() {
        let mut dests = vec![];
        for s in vec.into_iter() {
            if let Some(idxn) = node_map.get(&s) {
                dests.push(*idxn);
            }
        }
        edges.push((source, dests));
    }

    let mut map = HashMap::new();
    io.writedln(find_max(
        &mut nodes,
        &mut edges,
        26,
        *node_map.get("AA").unwrap(),
        *node_map.get("AA").unwrap(),
        &mut map,
    ));
    let mut res = 0;
    io.write("Part 1: ");
    io.writeln(res);
    io.write("Part 2: ");
    io.writeln(res);
}

fn find_max(
    nodes: &mut Vec<(usize, (usize, bool))>,
    edges: &mut Vec<(usize, Vec<usize>)>,
    iter: usize,
    curr_node: usize,
    elephant_node: usize,
    cache: &mut HashMap<(usize, usize, usize, Vec<(usize, bool)>), usize>,
) -> usize {
    let vec: Vec<(usize, bool)> = nodes.iter().map(|x| (x.0, x.1 .1)).collect();
    if let Some(res) = cache.get(&(iter, curr_node, elephant_node, vec.clone())) {
        return *res;
    }
    if iter == 0 {
        return 0;
    }
    let mut max = 0;
    // see if activating current node helps
    let mut can_try = true;
    {
        let curr = nodes.iter_mut().find(|x| x.0 == curr_node).unwrap();
        if curr.1 .1 || curr.1 .0 == 0 {
            can_try = false;
        }
    }
    let mut ecan_try = true;
    {
        let curr = nodes.iter_mut().find(|x| x.0 == elephant_node).unwrap();
        if curr.1 .1 || curr.1 .0 == 0 {
            ecan_try = false;
        }
    }
    if can_try && ecan_try && elephant_node != curr_node {
        {
            let curr = nodes.iter_mut().find(|x| x.0 == curr_node).unwrap();
            curr.1 .1 = true;
        }
        {
            let curr = nodes.iter_mut().find(|x| x.0 == elephant_node).unwrap();
            curr.1 .1 = true;
        }
        let val = find_max(nodes, edges, iter - 1, curr_node, elephant_node, cache);
        let add1 = {
            let curr = nodes.iter_mut().find(|x| x.0 == curr_node).unwrap();
            let add = (iter - 1) * curr.1 .0;
            curr.1 .1 = false;
            add
        };
        let add2 = {
            let curr = nodes.iter_mut().find(|x| x.0 == elephant_node).unwrap();
            let add = (iter - 1) * curr.1 .0;
            curr.1 .1 = false;
            add
        };
        if add1 + add2 + val > max {
            max = add1 + add2 + val;
        }
    }

    let dests = edges.iter().find(|&x| x.0 == curr_node).unwrap().1.clone();
    let edests = edges
        .iter()
        .find(|&x| x.0 == elephant_node)
        .unwrap()
        .1
        .clone();
    if can_try {
        let add = {
            let curr = nodes.iter_mut().find(|x| x.0 == curr_node).unwrap();
            curr.1 .1 = true;
            curr.1 .0 * (iter - 1)
        };
        for edest in edests.iter() {
            let val = find_max(nodes, edges, iter - 1, curr_node, *edest, cache);
            if add + val > max {
                max = add + val;
            }
        }
        {
            let curr = nodes.iter_mut().find(|x| x.0 == curr_node).unwrap();
            curr.1 .1 = false;
        }
    }
    if ecan_try {
        let add = {
            let curr = nodes.iter_mut().find(|x| x.0 == elephant_node).unwrap();
            curr.1 .1 = true;
            curr.1 .0 * (iter - 1)
        };
        for dest in dests.iter() {
            let val = find_max(nodes, edges, iter - 1, *dest, elephant_node, cache);
            if add + val > max {
                max = add + val;
            }
        }
        {
            let curr = nodes.iter_mut().find(|x| x.0 == elephant_node).unwrap();
            curr.1 .1 = false;
        }
    }

    // check every possible destination
    for dest in dests.iter() {
        for edest in edests.iter() {
            let val = find_max(nodes, edges, iter - 1, *dest, *edest, cache);
            if val > max {
                max = val;
            }
        }
    }
    cache.insert((iter, curr_node, elephant_node, vec), max);
    max
}
